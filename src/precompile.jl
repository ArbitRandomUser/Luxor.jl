# this file was generated by this code
# using SnoopCompile
# inf_timing = @snoopi tmin=0.01 include("test/runtests.jl")
# pc = SnoopCompile.parcel(inf_timing)
# SnoopCompile.write("/tmp/precompile", pc)
# I have no idea what's going on here...



# Use
#    @warnpcfail precompile(args...)
# if you want to be warned when a precompile directive fails
macro warnpcfail(ex::Expr)
    modl = __module__
    file = __source__.file === nothing ? "?" : String(__source__.file)
    line = __source__.line
    quote
        $(esc(ex)) || @warn """precompile directive
     $($(Expr(:quote, ex)))
 failed. Please report an issue in $($modl) (after checking for duplicates) or remove this directive.""" _file=$file _line=$line
    end
end


const __bodyfunction__ = Dict{Method,Any}()

# Find keyword "body functions" (the function that contains the body
# as written by the developer, called after all missing keyword-arguments
# have been assigned values), in a manner that doesn't depend on
# gensymmed names.
# `mnokw` is the method that gets called when you invoke it without
# supplying any keywords.
function __lookup_kwbody__(mnokw::Method)
    function getsym(arg)
        isa(arg, Symbol) && return arg
        @assert isa(arg, GlobalRef)
        return arg.name
    end

    f = get(__bodyfunction__, mnokw, nothing)
    if f === nothing
        fmod = mnokw.module
        # The lowered code for `mnokw` should look like
        #   %1 = mkw(kwvalues..., #self#, args...)
        #        return %1
        # where `mkw` is the name of the "active" keyword body-function.
        ast = Base.uncompressed_ast(mnokw)
        if isa(ast, Core.CodeInfo) && length(ast.code) >= 2
            callexpr = ast.code[end-1]
            if isa(callexpr, Expr) && callexpr.head == :call
                fsym = callexpr.args[1]
                if isa(fsym, Symbol)
                    f = getfield(fmod, fsym)
                elseif isa(fsym, GlobalRef)
                    if fsym.mod === Core && fsym.name === :_apply
                        f = getfield(mnokw.module, getsym(callexpr.args[2]))
                    elseif fsym.mod === Core && fsym.name === :_apply_iterate
                        f = getfield(mnokw.module, getsym(callexpr.args[3]))
                    else
                        f = getfield(fsym.mod, fsym.name)
                    end
                else
                    f = missing
                end
            else
                f = missing
            end
        else
            f = missing
        end
        __bodyfunction__[mnokw] = f
    end
    return f
end

function _precompile_()
    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing
    Base.precompile(Tuple{Core.kwftype(typeof(circlepath)),NamedTuple{(:reversepath,), Tuple{Bool}},typeof(circlepath),Point,Int64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(crescent)),NamedTuple{(:vertices, :reversepath), Tuple{Bool, Bool}},typeof(crescent),Point,Int64,Point,Int64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(crescent)),NamedTuple{(:vertices, :reversepath, :steps), Tuple{Bool, Bool, Int64}},typeof(crescent),Point,Int64,Int64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(crescent)),NamedTuple{(:vertices,), Tuple{Bool}},typeof(crescent),Point,Float64,Float64})
    Base.precompile(Tuple{Core.kwftype(typeof(ellipse)),NamedTuple{(:stepvalue, :vertices, :reversepath), Tuple{Float64, Bool, Bool}},typeof(ellipse),Point,Point,Point,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(epitrochoid)),NamedTuple{(:action, :close, :stepby, :vertices), Tuple{Symbol, Bool, Float64, Bool}},typeof(epitrochoid),Int64,Int64,Int64})
    Base.precompile(Tuple{Core.kwftype(typeof(epitrochoid)),NamedTuple{(:close, :stepby, :vertices), Tuple{Bool, Float64, Bool}},typeof(epitrochoid),Int64,Int64,Int64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(hypotrochoid)),NamedTuple{(:close, :stepby, :vertices), Tuple{Bool, Float64, Bool}},typeof(hypotrochoid),Int64,Int64,Int64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(ngon)),NamedTuple{(:action,), Tuple{Symbol}},typeof(ngon),Int64,Int64,Int64,Int64})
    Base.precompile(Tuple{Core.kwftype(typeof(ngon)),NamedTuple{(:vertices, :reversepath), Tuple{Bool, Bool}},typeof(ngon),Point,Int64,Int64,Float64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(ngon)),NamedTuple{(:vertices,), Tuple{Bool}},typeof(ngon),Point,Int64,Int64})
    Base.precompile(Tuple{Core.kwftype(typeof(polycross)),NamedTuple{(:vertices, :reversepath), Tuple{Bool, Bool}},typeof(polycross),Point,Int64,Int64,Float64,Float64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(prettypoly)),NamedTuple{(:action, :close), Tuple{Symbol, Bool}},typeof(prettypoly),Vector{Point}})
    Base.precompile(Tuple{Core.kwftype(typeof(prettypoly)),NamedTuple{(:action,), Tuple{Symbol}},typeof(prettypoly),BoundingBox})
    Base.precompile(Tuple{Core.kwftype(typeof(prettypoly)),NamedTuple{(:close,), Tuple{Bool}},typeof(prettypoly),Vector{Point},Symbol,Function})
    Base.precompile(Tuple{Core.kwftype(typeof(prettypoly)),NamedTuple{(:close,), Tuple{Bool}},typeof(prettypoly),Vector{Point},Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(spiral)),NamedTuple{(:stepby, :period, :vertices, :log), Tuple{Float64, Float64, Bool, Bool}},typeof(spiral),Int64,Int64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(squircle)),NamedTuple{(:rt, :vertices, :stepby, :reversepath), Tuple{Float64, Bool, Float64, Bool}},typeof(squircle),Point,Int64,Int64,Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(star)),NamedTuple{(:action, :vertices, :reversepath), Tuple{Symbol, Bool, Bool}},typeof(star),Int64,Int64,Int64,Int64,Float64,Float64})
    Base.precompile(Tuple{Core.kwftype(typeof(star)),NamedTuple{(:vertices, :reversepath), Tuple{Bool, Bool}},typeof(star),Point,Int64,Int64,Float64,Irrational{:Ï€},Symbol})
    Base.precompile(Tuple{Core.kwftype(typeof(textoutlines)),NamedTuple{(:action, :halign, :valign, :startnewpath), Tuple{Symbol, Symbol, Symbol, Bool}},typeof(textoutlines),String,Point})
    Base.precompile(Tuple{Type{BoundingBox}})
    Base.precompile(Tuple{Type{Drawing}})
    Base.precompile(Tuple{typeof(arc2r),Point,Point,Point,Symbol})
    Base.precompile(Tuple{typeof(arc2sagitta),Point,Point,Int64,Symbol})
    Base.precompile(Tuple{typeof(box),Point,Int64,Int64,Int64,Symbol})
    Base.precompile(Tuple{typeof(center3pts),Point,Point,Point})
    Base.precompile(Tuple{typeof(ngon),Int64,Int64,Int64,Int64,Symbol})
    Base.precompile(Tuple{typeof(ngon),Point,Float64,Int64,Int64,Symbol})
    Base.precompile(Tuple{typeof(ngon),Point,Int64,Int64})
    Base.precompile(Tuple{typeof(sector),Float64,Float64,Float64,Float64,Int64,Symbol})
    Base.precompile(Tuple{typeof(sector),Point,Int64,Int64,Int64,Float64,Int64,Symbol})
    Base.precompile(Tuple{typeof(snapshot)})
    let fbody = try __lookup_kwbody__(which(arrow, (Point,Point,Vector{Int64},Symbol,))) catch missing end
        if !ismissing(fbody)
            precompile(fbody, (Int64,Int64,Float64,Bool,Bool,Bool,Float64,Function,Nothing,typeof(arrow),Point,Point,Vector{Int64},Symbol,))
        end
    end
end
